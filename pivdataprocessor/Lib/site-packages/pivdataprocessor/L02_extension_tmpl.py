''' 
=========================
= Author:   HAN Zexu    =
= Version:  1.0         =
= Date:     2025/04/09  =
=========================
'''

import numpy as np
from .L01_base import PIVDataProcessorBase as pBase
from .A01_toolbox import float_precsion
import os, inspect, shutil, sys
from dataclasses import dataclass, asdict, fields
import json
from abc import ABC, abstractmethod

class PIVDataProcessorExtensionTemplate(pBase):
    def __init__(self, casename:str):
        super().__init__()
        pBase.load_case(casename=casename)
        self.casename = pBase.CaseInfo.CaseName
        self.result_path  = self.__getpath() + '/' + self.casename
    
    def __getpath(self) -> str:
        frame = inspect.stack()[2]
        module = inspect.getmodule(frame[0])
        current_file_path = os.path.abspath(module.__file__)
        c_file_path, c_file_name = os.path.split(current_file_path) 
        cwd = pBase.Paths.Working_path
        c_relative_path = os.path.relpath(c_file_path, start=cwd)
        plot_path = cwd + pBase.Paths.Plot_foldername + '/' + c_relative_path + '/' + c_file_name[:-3]
        return plot_path
    
    def report(self, str:str):
        self.pBasereport(str, self.result_path + '/log.txt')

class GeneralTemplate():
    def __init__(self, result_path_name = '00_Results', if_save_in_S02:bool = True):
        self.result_path = self.__getpath() + '/' + result_path_name

    def __getpath(self) -> str:
        frame = inspect.stack()[2]
        module = inspect.getmodule(frame[0])
        current_file_path = os.path.abspath(module.__file__)
        c_file_path, c_file_name = os.path.split(current_file_path) 
        return c_file_path    

    @classmethod    
    def rm_and_create_directory(cls, path_to_directory:str) -> None:
        if os.path.exists(path_to_directory):
            shutil.rmtree(path_to_directory)
        os.makedirs(path_to_directory)     
 
    def GTreport(self, str:str = '', logfile:str = '', ifinit = False) -> None:
        '''
            Custom print().

            No need to pay extra attention.
        '''
        if logfile == '':
            logfile = self.result_path+'/log.txt'
        else:
            logfile = self.result_path + logfile
        if ifinit == True:
            with open(logfile,'w') as f:
                sys.stdout = f
                print(str)
        else:
            with open(logfile,'a') as f:
                sys.stdout = f
                print(str)            
        sys.stdout = sys.__stdout__

    @classmethod
    def save_nparray_to_bin(cls, quantity:np.ndarray, datapath:str):
        with open(datapath, 'wb') as f:
            quantity.tofile(f)  

    @classmethod
    def load_nparray_from_bin(cls, quantity: np.ndarray, datapath:str, dtype=float_precsion) -> np.ndarray:
        shape = quantity.shape
        quantity = np.fromfile(datapath, dtype = dtype).reshape(shape)
        return quantity
    
class LinkedListNodeBase(ABC):
    '''Example:
    class MyNode(LinkedListNodeBase):
        def __init__(self, value: np.ndarray, tag=None, next_node=None):
            super().__init__(next_node)
            self.value = value  
            self.tag = tag     

        def to_dict(self):
            return {
                'value': self.value.tolist(), 
                'tag': self.tag
            }

        @classmethod
        def from_dict(cls, d):
            value = np.array(d['value'])
            return cls(value=value, tag=d.get('tag'))

    if __name__ == "__main__":
        n2 = MyNode(np.array([3, 4]), tag='b')
        n1 = MyNode(np.array([1, 2]), tag='a', next_node=n2)
        n1.save('linked_array.json')

        head = MyNode.load('linked_array.json')
        current = head
        while current:
            print(f'value: {current.value}, tag: {current.tag}, type: {type(current.value)}')
            current = current.next
    '''
    def __init__(self, next_node=None):
        self.next = next_node

    def to_list(self):
        result = []
        current = self
        while current:
            result.append(current.to_dict())
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        head = None
        for item in reversed(data_list):
            node = cls.from_dict(item)
            node.next = head
            head = node
        return head

    def save(self, filename):
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.to_list(), f, indent=2)

    @classmethod
    def load(cls, filename):
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return cls.from_list(data)

    @abstractmethod
    def to_dict(self):
        pass

    @classmethod
    @abstractmethod
    def from_dict(cls, d):
        pass